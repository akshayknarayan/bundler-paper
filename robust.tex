\section{Robustness}\label{s:robust}

We now ask whether \name can effectively shift the bottleneck under a variety of conditions.

\subsection{Cross Traffic}\label{s:robust:cross}

The characteristics of other traffic --- not part of the traffic aggregate \name controls --- on the link can force \name's congestion controller to yield queue size to remain competitive in the bottleneck link.
\an{Should we say this? :}Note that under more challenging network conditions --- oversubscription, etc --- the role an importance of \name' congestion controller is more important. We anticipate that future work in congestion control may yield better results.

\input{inelastic-cross}
\paragrapha{Inelastic Cross Traffic} We first consider the case of \emph{inelastic} cross traffic; that is, traffic that does not respond to queue-size fluctuations.
For example, traffic primarily comprised of short web requests has the inelastic property because regardless of what \name's congestion controller (or any end-to-end congestion controller) does, the component short requests, which remain in TCP slow start for their entirety, will occupy some fraction of the bottleneck link capacity.
In this case, the congestion controller must yield bandwidth to the cross traffic, but can still maintain low delays at the bottleneck link.

We can see this phenomenon in action in Figure~\ref{fig:robust:cr-inelastic}. 
Each of the congestion control algorithms we evaluate sacrifice (to varying degrees) bandwidth in reaction to the cross traffic, which hurts the FCTs of the larger requests.
However, the scheduling policy apportions the remaining bandwidth to the short flows, so there is still an improvement in FCTs at the median.

\input{elastic-cross}
\paragrapha{Elastic Cross Traffic} Elastic cross traffic, which fills the bottleneck link's buffer, is the worst-case scenario for \name.
The congestion controller must push packets into the bottleneck queue to compete fairly, and thus it cannot retain packets at the \inbox to schedule.
As a result, we expect performance to be no better than the baseline.
We indeed see this in Figure~\ref{fig:robust:cr-elastic}.

It is important to note that traditional loss-based congestion controllers (\ie Cubic~\cite{cubic}, NewReno~\cite{reno}) are poor choices for \name. 
This is because they double-penalize component traffic for losses: first, in the reaction of the end-to-end congestion controller to the loss, and second in the reaction of the controller at \name.
Therefore, for algorithms which observe loss (Nimbus and Copa), we configure them to ignore it; the end-to-end reaction to loss will modulate the offered load to be the fair share of the bottleneck.

In this experiment, Copa, primarily a delay-based algorithm, cannot adequately detect the presence of competing elastic traffic and ``mode-switch'' to its competitive mode. \an{add line for copa-on-nimbus}

\subsection{Path Characteristics}\label{s:robust:path}
\begin{outline}
\1 Different RTTs
\1 Different bandwidths
\end{outline}
