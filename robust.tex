\section{Robustness}\label{s:robust}

We now ask whether \name can effectively shift the bottleneck under a variety of conditions.

\subsection{Cross Traffic}\label{s:robust:cross}

The characteristics of other traffic --- not part of the traffic aggregate \name controls --- on the link can force \name's congestion controller to behave more aggressively in order to remain competitive in the bottleneck link. This would reduce the amount of queue build up at the \name, thus reducing its benefits.
\an{Should we say this? :}Note that under more challenging network conditions --- over-subscription, etc --- the role an importance of \name' congestion controller is more important. \radhika{don't understand what you mean by this} As we discuss in \S\ref{s:discussion}, we anticipate that future work in congestion control may yield better results.

\input{inelastic-cross}
\paragrapha{Inelastic Cross Traffic} We first consider the case of \emph{inelastic} cross traffic; that is, traffic that does not respond to queue-size fluctuations.
For example, traffic primarily comprised of short web requests has the inelastic property because regardless of what \name's congestion controller (or any end-to-end congestion controller) does, the component short requests, which remain in TCP slow start for their entirety, will occupy some fraction of the bottleneck link capacity.
In this case, the congestion controller must yield bandwidth to the cross traffic, but can still maintain low delays at the bottleneck link.

We can see this phenomenon in action in Figure~\ref{fig:robust:cr-inelastic}. 
Each of the congestion control algorithms we evaluate sacrifice (to varying degrees) bandwidth in reaction to the cross traffic, which hurts the FCTs of the larger requests.
However, the scheduling policy apportions the remaining bandwidth to the short flows, so there is still an improvement in FCTs at the median.

\radhika{it might be ok to just present the Copa results here.}

\input{elastic-cross}
\paragrapha{Elastic Cross Traffic} Elastic cross traffic, which fills the bottleneck link's buffer, is the worst-case scenario for \name.
The congestion controller must push packets into the bottleneck queue to compete fairly, and thus it cannot retain packets at the \inbox to schedule.
As a result, we expect performance to be no better than the baseline.
We indeed see this in Figure~\ref{fig:robust:cr-elastic}.

In this experiment, Copa, primarily a delay-based algorithm, cannot adequately detect the presence of competing elastic traffic and ``mode-switch'' to its competitive mode. When we modify Copa to use Nimbus's elasticity detector (Figure~\ref{fig:robust:cr-elastic:b}), its performance matches the baseline.
\radhika{it might be cleaner to just present the Copa results here, i.e. just Figure~\ref{fig:robust:cr-elastic:b}.}

\radhika{Also, is it possible to try what was discussed in the meeting the other day? i.e. hold traffic at the bundler for some fixed small time (10\%) of RTT and to induce some queuing? not sure if it will help though....most likely not.} \an{not sure what this is? let's discuss}

\input{twobundler}
\paragrapha{Competing Bundles} \name's improvements return once competing traffic starts using \name as well. In Figure~\ref{fig:robust:twobundler}, we show the performance of each of two bundles of traffic competing in the same bottleneck link. 
Despite both bundles containing persistently backlogged flows, just as in Figure~\ref{fig:robust:cr-elastic}, here \name improves the FCTs of both bundles independently.

\subsection{Path Characteristics}\label{s:robust:path}
\an{should these go in ``microbenchmarks'' in \S\ref{s:measurement}?} \radhika{i don't think so}
\begin{outline}
\1 Different RTTs
\1 Different bandwidths
\end{outline}