\section{Discussion}\label{s:discussion}

\paragrapha{Scheduling across different bundles at a \inbox} We evaluate benefits of scheduling \emph{within} a bundle. In practice, a given \inbox will see traffic from multiple bundles. Extending different scheduling policies to multiple such bundles can be done trivially.

\paragrapha{Rate allocation across different competing bundles} When multiple bundles, belonging to different sending domains, compete at the same bottleneck, \name's congestion control would ensure a fair rate allocation across each of these bundles, irrespective of the amount of traffic in them. It, therefore, provides fairness on per-sending domain basis, as opposed to a per-flow basis, making it more robust to strategies like opening multiple connections for increasing bandwidth share. 


% Our \name design addresses scheduling \emph{within} a bundle. In our system, scheduling \emph{across} bundles is implicit; each bundle's congestion control algorithm will converge to an aggregate rate.  \name therefore inherits the well-studied strengths and weaknesses of using congestion control for rate allocation. Just as users choose a congestion control algorithm as a point in the tradeoff space between aggressiveness and cooperation at the endhost, network operators deploying a \name would pick a configuration appropriate for their workload.

% In the case where a sending domain controls multiple bundles (to different destination domains) it could apply scheduling policies across them.
% \fc{We should say something somewhere about sched across bundles and in-bundle/out-of-bundle}


% \paragrapha{Scheduling and rate allocation across bundles} Our \name design addresses scheduling \emph{within} a bundle. In our system, scheduling \emph{across} bundles is implicit; each bundle's congestion control algorithm will converge to an aggregate rate. 
% \name therefore inherits the well-studied strengths and weaknesses of using congestion control for rate allocation. 
% Just as users choose a congestion control algorithm as a point in the tradeoff space between aggressiveness and cooperation at the endhost, network operators deploying a \name would pick a configuration appropriate for their workload.

% In the case where a sending domain controls multiple bundles (to different destination domains) it could apply scheduling policies across them.
% \fc{We should say something somewhere about sched across bundles and in-bundle/out-of-bundle}
 
\paragrapha{Bundle Initialization}\label{s:impl:discovery}
In most cases, it is practical to statically configure a \pair. This is trivial if the sending and receiving domains belong to the same entity. In the case where the sending domain is a large content providers, it can advertise its \inbox address, with which a local \outbox can establish pairing. 
%or use the DNS to globally coordinate \name coverage across IP subnets.
%Different bundles may have different rates; recent work~\cite{carousel, eifel} has shown it is possible to implement such multi-rate, multi-scheduler datapaths efficiently.



%The \outbox does one of two things for each potential epoch boundary packet:
%\begin{enumerate}
%    \item If the packet is in a known bundle, the \outbox sends a message to the corresponding \inbox.
%    \item If the packet is not in a known bundle, the \outbox sends a message to the source IP address of that packet.
%\end{enumerate}

%The \inbox receives (and intercepts) the \outbox feedback.  
%The \inbox at this time updates its flow tables to add the destination IP of the epoch boundary packet either to an existing bundle (in the case of a new flow from a previously-unseen source subnet joining a bundle) or instantiates a new bundle.
%The \inbox then sends a response containing an epoch size to use and the hash of the epoch boundary packet.
%The \outbox receives this message, initializes a byte counter for the newly discovered bundle, and remembers the \inbox IP address for future feedback. If there is no \inbox on the path, the packet will simply be ignored at its destination. 


\paragrapha{Benefits of delay-based congestion control} A delay-based congestion control allows maintaining low packet delays in the network. Deploying such algorithms at each individual endhosts is difficult. \name provides a way to reap benefits of such algorithms, by simply deploying a middlebox, without changing individual endpoints.

\cut{
\paragrapha{Endhost Congestion Control}
We note in \S\ref{s:eval:cc} that \name's performance changes when the endhost congestion control algorithm changes.
If the endhost uses a delay-based congestion controller, it will not build queues at \name.
If \emph{all} such endhosts deploy delay-control schemes---an unlikely scenario, as endhost congestion control is difficult to evolve~\cite{quic}---\name may have limited ability to schedule packets.
However, we note that using delay-based congestion controllers is an expression of a desired scheduling policy: namely, low packet delays.
\name is thus compatible with this method of enforcing endhost scheduling policy, while additionally enabling isolation of the delay-sensitive traffic (via scheduling) from other flows.
Furthermore, \name can realize the benefits of recent developments in congestion control, as it can use AQM at the \inbox to achieve similar goals. 
}
%
\cut{}
